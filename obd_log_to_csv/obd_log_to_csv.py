# OBD Log To CSV
# obd_log_to_csv/obd_log_to_csv.py
import json
import csv
from argparse import ArgumentParser
from io import TextIOWrapper
from pint import UnitRegistry, UndefinedUnitError, OffsetUnitCalculusError
from dateutil import parser

unit_registry = UnitRegistry()
# The following units aren't included in the base pint package
# and are needed to process data generated by python-obd project.
unit_registry.define("percent = [] = %")
unit_registry.define("ratio = []")
unit_registry.define("gps = gram / second = GPS = grams_per_second")
unit_registry.define("lph = liter / hour = LPH = liters_per_hour")
unit_registry.define("ppm = count / 1000000 = PPM = parts_per_million")

date_time_fields = ['iso_ts_pre', 'iso_ts_post', 'duration', ]

def pint_to_value(obd_response_value:str, verbose:bool=False):
    """Returns a workable obd_response_value.
       When obd_response_values are numeric, they are expressed as
        - number, 
        - single space and
        - units,
       they will be translated to just a number.
       Sometimes obd_response_values are 'not supported' in which case
       they will be replaced with None.
       Othertimes obd_response_values will be a string which may or may not
       contain commas.  In this case, the string will be wrapped with double
       quotes.
    """
    if obd_response_value == 'not supported':
        return None

    try:
        pint_value = unit_registry(obd_response_value)
    except UndefinedUnitError:
        return obd_response_value
    except OffsetUnitCalculusError as e:
        if verbose:
            print(f"Pint unit_registry error on {obd_response_value}. " +
            f"Returning \"{(obd_response_value.split())[0]}\" as value")
        return (obd_response_value.split())[0]

    return (pint_value.to_tuple())[0]

def null_out_output_record(output_record:dict, commands:list) -> None:
    """Nulls out the values within the output record dictionary.
    """
    for command in commands:
        output_record[command] = None
    output_record['iso_ts_pre'] = None
    output_record['iso_ts_post'] = None
    output_record['duration'] = None

def csv_header(commands:list) -> list:
    return commands + ['iso_ts_pre', 'iso_ts_post', 'duration', ]

def input_file(json_input:TextIOWrapper, commands:list, csv_output:TextIOWrapper, header:bool=True, verbose:bool=False) -> None:
    """process input file given an open file handle for input,
        a list of OBD commands to include in the output and
        an output file handle for the CSV output file.
    """
    output_record = {}
    null_out_output_record(output_record, commands)
    output_record_is_nulled_out = True
    field_names = commands + date_time_fields

    writer = csv.DictWriter(csv_output, fieldnames=field_names)

    if header:
        writer.writeheader()

    for json_record in json_input:
        try:
            input_record = json.loads(json_record)
        except json.decoder.JSONDecodeError as e:
            # improperly closed JSON file
            if verbose:
                print(f"Corrupted JSON info:\n{e}")
            return

        command_name = input_record['command_name']
        if command_name not in commands:
            continue

        if verbose:
            print(f"input_record: {command_name} value: {input_record['obd_response_value']}")

        if output_record[command_name]:
            output_record['duration'] = output_record['iso_ts_post'] - output_record['iso_ts_pre']

            writer.writerow(output_record)

            null_out_output_record(output_record, commands)
            output_record_is_nulled_out = True

        if output_record_is_nulled_out:
            output_record_is_nulled_out = False
            output_record['iso_ts_pre'] = parser.isoparse(input_record['iso_ts_pre'])

        output_record[command_name] = pint_to_value(input_record['obd_response_value'], verbose)
        output_record['iso_ts_post'] = parser.isoparse(input_record['iso_ts_post'])

def main():
    parser = ArgumentParser(prog="obd_log_to_csv", description="Telemetry OBD Log To CSV")

    parser.add_argument(
        "--commands",
        help="""Command name list to include in CSV output record generation.
                Comma separated list.  e.g. "SPEED,RPM,FUEL_RATE".
                In the JSON input, "command_name" labelled items will be used.
                Defaults to all distinct command names in the set of files.
                """,
        nargs="?",
    )

    parser.add_argument(
        "--csv",
        help="""CSV output file.
                File can be either a full or relative path name.
                If the file already exists, it will be overwritten.
                """,
    )

    parser.add_argument(
        "--no_header",
        help="""CSV output file will NOT have a column name header record.
                Default is False.  (That is, a header will be produced by default.)
        """,
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--verbose",
        help="Turn verbose output on. Default is off.",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "files",
        help="""telemetry_obd generated data files separated by spaces.
                Data file names can include full or relative paths.
            """,
        default=None,
        nargs="+",
    )

    args = vars(parser.parse_args())

    json_input_files = args['files']
    csv_output_file_name = args['csv']
    header = not args['no_header']
    verbose = args['verbose']
    commands = (args['commands']).split(sep=',')

    if verbose:
        print(f"verbose: {args['verbose']}")
        print(f"commands: {args['commands']}")
        print(f"header: {header}")
        print(f"files: {json_input_files}")
        print(f"csv: {csv_output_file_name}")

    with open(csv_output_file_name, "w") as csv_output_file:
        for json_input_file_name in json_input_files:
            if verbose:
                print("processing input file {json_input_file_name}")
            with open(json_input_file_name, "r") as json_input:
                input_file(json_input, commands, csv_output_file, header=header, verbose=verbose)
            header = False

if __name__ == "__main__":
    main()
