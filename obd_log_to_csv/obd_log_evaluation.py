# OBD Log Evaluation
# telemetry-obd-log-to-csv/obd_log_to_csv/obd_log_evaluation.py
import json
import csv
from sys import stdout
from argparse import ArgumentParser
from pint import UnitRegistry, UndefinedUnitError, OffsetUnitCalculusError
from rich.console import Console
from rich.table import Table

unit_registry = UnitRegistry()

# The following units aren't included in the base pint package
# and are needed to process data generated by python-obd project.
unit_registry.define("percent = [] = %")
unit_registry.define("ratio = []")
unit_registry.define("gps = gram / second = GPS = grams_per_second")
unit_registry.define("lph = liter / hour = LPH = liters_per_hour")
unit_registry.define("ppm = count / 1000000 = PPM = parts_per_million")
unit_registry.define("degC = Centigrade")

def csv_print(raw_data:dict, verbose=False):
    field_names = [
        'command',
        'count',
        'no response',
        'data type',
        'units',
    ]
    writer = csv.DictWriter(stdout, fieldnames=field_names)

    for key, value in raw_data.items():
        if verbose:
            print(f"csv_print(): key {key}")
        value['command'] = key
        writer.writerow(value)

def rich_output(raw_data:dict, verbose=False):
    console = Console()

    table = Table(show_header=True, header_style="bold magenta")
    table.add_column("OBD Command", justify='left')
    table.add_column("Count", justify='right')
    table.add_column("No Response", justify='right')
    table.add_column('Data Type', justify='left')
    table.add_column("Units", justify="left")

    count_total = 0
    no_response_total = 0

    for key, value in raw_data.items():
        count_total += value['count']
        no_response_total += value['no response']

        value_key = key
        value_count = str(value['count'])
        value_no_response = str(value['no response'])

        if value['count'] == value['no response']:
            value_key = f"[bold red]{key}[/bold red]"
            value_count = f"[bold red]{value['count']}[/bold red]"
        if value['no response'] > 0:
            value_no_response = f"[bold red]{value['no response']}[/bold red]"

        table.add_row(
            value_key,
            value_count,
            value_no_response,
            value['data type'],
            value['units'],
        )

    table.add_row(
        '[bold]TOTALS[/bold]',
        f"[bold]{count_total}[/bold]",
        f"[bold red]{no_response_total}[/bold red]",
        '',
        ''
    )

    console.print(table)


def get_data_type(data)->str:
    if isinstance(data, str):
        return 'string'
    if isinstance(data, int):
        return 'integer'
    if isinstance(data, float):
        return 'float'
    return None

def pint_to_value_type(obd_response_value:str, verbose:bool=False):
    """Returns a workable obd_response_value.
       When obd_response_values are numeric, they are expressed as
        - number, 
        - single space and
        - units,
       they will be translated to just a number.
       Sometimes obd_response_values are 'no response' in which case
       they will be replaced with None.
       Othertimes obd_response_values will be a string which may or may not
       contain commas.  In this case, the string will be wrapped with double
       quotes.
    """
    if obd_response_value in {'no response', 'not supported'}:
        return None, None

    try:
        pint_value = unit_registry(obd_response_value)
    except UndefinedUnitError:
        return obd_response_value, None
    except OffsetUnitCalculusError as e:
        if verbose:
            print(f"Pint unit_registry error on {obd_response_value}. " +
            f"Returning \"{(obd_response_value.split())[0]}\" as value")
        return (obd_response_value.split())[0], None

    try:
        value, units = pint_value.to_tuple()
    except AttributeError as e:
        if verbose:
            print(f"Pint unit_registry error on {obd_response_value}. ",
                    f"AttributeError: {e}")
        return pint_value, None

    return value, units[0][0]

def input_file(json_input_files, verbose=False)->dict:
    raw_data = {}

    for json_input_file_name in json_input_files:
        if verbose:
            print(f"processing input file {json_input_file_name}")
        with open(json_input_file_name, "r") as json_input:
            for json_record in json_input:
                try:
                    input_record = json.loads(json_record)
                except json.decoder.JSONDecodeError as e:
                    # improperly closed JSON file
                    if verbose:
                        print(f"Corrupted JSON info:\n{e}")
                    break

                command_name = input_record['command_name']
                if command_name not in raw_data:
                    raw_data[command_name] = {
                        'count': 0,
                        'no response': 0,
                        'data type': None,
                        'units': None,
                    }
                obd_response_value = input_record['obd_response_value']
                raw_data[command_name]['count'] += 1
                if obd_response_value in ['no response', 'not supported']:
                    raw_data[command_name]['no response'] += 1
                else:
                    value, pint_units = pint_to_value_type(obd_response_value, verbose)
                    data_type = get_data_type(value)
                    if verbose:
                        print(f"command_name: {command_name} value: {value}, pint_units: {pint_units} data_type: {data_type}")
                    if data_type:
                        raw_data[command_name]['data type'] = data_type
                    if pint_units:
                        raw_data[command_name]['units'] = pint_units
    return raw_data

def command_line_options()->dict:
    parser = ArgumentParser(prog="obd_log_evaluation",
                        description="""OBD Log Evaluation
                        performs simple analysis on telemetry_obd.obd_logger
                        and telemetry_obd.obd_command_tester output files.
                        The analysis is oriented toward validating obd_logger
                        config files and providing units for each OBD command.
                        """)

    parser.add_argument(
        "--verbose",
        help="Turn verbose output on. Default is off.",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "--csv",
        help="Output CSV on stdout.  Default is to rich table print on stdout.",
        default=False,
        action='store_true'
    )

    parser.add_argument(
        "files",
        help="""telemetry_obd generated data files separated by spaces.
                Data file names can include full or relative paths.
            """,
        default=None,
        nargs="+",
    )

    return vars(parser.parse_args())


def main():
    args = command_line_options()

    json_input_files = args['files']
    verbose = args['verbose']
    csv_output = args['csv']

    if verbose:
        print(f"verbose: {verbose}")
        print(f"csv: {csv_output}")
        print(f"files: {json_input_files}")

    raw_data = input_file(json_input_files, verbose=verbose)

    if not csv_output:
        rich_output(raw_data, verbose=verbose)
    else:
        csv_print(raw_data, verbose=verbose)


if __name__ == "__main__":
    main()
